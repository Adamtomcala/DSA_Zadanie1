#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#pragma warning(disable:4996)
#define N 200000


void* pointer;

//hlaviËka zaËaitku pola + hlaviËka volnej Ëasti pamate
typedef struct Header {
    unsigned   int sizeOfMemory;
    unsigned   int size;
    struct Header* next;
}HEADER;


//hlaviËka alokovanej Ëasti pamate
typedef struct HeaderOfAlocated {
    unsigned short int size;
}HEADERA;


void memory_init(void* ptr, unsigned int size) {
    char* zaciatok = (char*)ptr;
    //inicializacia zadanej Ëasti poæa na -2
    for (int i = 0; i < size; i++, zaciatok++) {
        *zaciatok = -2;
    }
    //vytvorenie hlavnej hlaviËky
    HEADER* header = (HEADER*)ptr;
    header->size = size - sizeof(HEADER) - sizeof(HEADERA);
    header->sizeOfMemory = size;
    header->next = NULL;

}

int memory_check(void* ptr) {
    char* valid = (char*)ptr;

    if (*(valid) == -1) {
        return 1;
    }
    else {
        return 0;
    }
}

void* memory_alloc(unsigned long size) {
    HEADER* header = (HEADER*)pointer;
    HEADER* curr = header;
    char* start_memory = (char*)pointer;

    //toto je prÌpad, ak sa za hlavnou hlaviËkou nach·dza NULL pointer, Ëo znaËÌ, ûe v poli eöte nie je niË alokovanÈ
    if (header->next == NULL) {
        //ak je veækosù voænej pamate viac alebo sa rovn· veækosti pamate, ktor˙ chceme alokovaù -> tak ju alokujeme
        if (header->size >= size) {
            //toto je prÌpad, ak alokujem toæko pamate, ûe neostane miesto pre Ôalöiu hlaviËku, ktor· oznaËuje ÔalöÌ voæn˝ blok
            //tak toto miesto prid·m k alokovanej pamati, aby mi neostalo zbytoËne nevyuûitÈ miesto
            if (header->size < size + sizeof(HEADER) + sizeof(HEADERA)) {
                HEADERA* new_headerA = (HEADERA*)(start_memory + sizeof(HEADER));
                new_headerA->size = header->size;
                header->size = 0;
                memset(start_memory + sizeof(HEADER) + sizeof(HEADERA), -1, new_headerA->size);
                return (start_memory + sizeof(HEADER) + sizeof(HEADERA));
            }
            //toto je prÌpad, ak tam je miesto aj na Ôalöiu hlaviËku, ktor· ukazuje na Ôalöie voænÈ miesto v pamati
            else {
                HEADERA* new_headerA = (HEADERA*)(start_memory + sizeof(HEADER));
                new_headerA->size = size;
                memset(start_memory + sizeof(HEADER) + sizeof(HEADERA), -1, size);
                HEADER* new_headerF = (HEADER*)(start_memory + sizeof(HEADER) + sizeof(HEADERA) + size);
                new_headerF->size = header->size - size - sizeof(HEADERA);
                new_headerF->sizeOfMemory = header->sizeOfMemory;
                new_headerF->next = NULL;
                header->next = new_headerF;
                header->size = 0;
                return (start_memory + sizeof(HEADER) + sizeof(HEADERA));
            }
        }
        //ak nie je dostatok miesta na alokovanie pamate vypÌöe sa v˝pis a vr·ti sa NULL
        else {
            return NULL;
        }
    }
    //toto else zanËÌ to, ûe uû sa do pamate niekedy nieËo alokovalo 
    else {
        HEADER* previous;
        HEADER* thebest = NULL;

        int minimum = N;    //premenn·, ktor· oznaËuje minim·lny zvyöok, ktor˝ sa n·jde, aby ost·vali vûdy Ëo najmenöie voænÈ k˙sky a vyuûilo sa Ëo najviac pam‰te 

        //flag mi oznaËuje to, ûe mi naölo nejak˙ voænu Ëasù pam‰te, a ak flag ostane 0 aj po vykonanÌ while-u, tak to znamen·, ûe sa nenaölo 
        //dostatoËne veækÈ miesto na alokovanie danej veækosti

        int flag = 0;
        int flag2 = 0;      //pomocn· premenn·
        int count = 0;
        int pozicia = 1;    //premenn· pozÌcia mi sl˙ûi na to, aby som zistil pozÌciu bloku, ktor˝ najviac vyhovuje

        //tento while mi prech·dza vöetky voænÈ pamate, pretoûe chcem n·jsù take voænÈ miesto 
        //v pamati, ktore bude svojou veækosùou, Ëo najbliûöie
        //k veækosti pamate, ktor˙ chcem alokovaù (the best fit)
        while (curr != NULL) {
            flag2 = 0;
            //je tu break preto, lebo ak sa najde presne tak· voæn· pamaù s presnou veækosùou, nemusÌm hæadaù Ôalej
            if (curr->size == size) {
                count++;
                pozicia = count;
                thebest = curr;
                flag = 1;
                break;
            }
            //podmienka, ktor· mi zabezpeËÌ to, ûe n·jdem tak˙ Ëasù volnej pamate, pri ktorej bude najmenöia fragment·cia
            if (curr->size > size && minimum > curr->size - size) {
                minimum = curr->size - size - 1;
                thebest = curr;
                flag = 1;
                count++;
                pozicia = count;
                flag2 = 1;
            }
            if (!flag2) {
                count++;
            }
            curr = curr->next;
        }

        //ak sa nenaöla ûiadna pamaù s dostatoËnou veækostou vypÌöe sa v˝pis a vr·ti sa NULL
        if (!flag) {
            return NULL;
        }

        previous = header;

        //ak bude pozicia = 1 znamen· to, ûe najlepöÌ kandid·t bola pamaù, ktor· m· ako hlaviËku hlavn˙ hlaviËku
        if (pozicia == 1) {
            char* curr_memory = (char*)thebest;
            HEADERA* new_nodeA = (HEADERA*)(curr_memory + sizeof(HEADER));

            //t·to podmienka overuje to, Ëi sa zo zvyöku, ktor˝ ostal d· vyuûiù eöte nejak· pamaù, ak ostane tak· pamaù, ktor· je mal·
            //vst˙pi to do "if" a zvyön˙ pam‰ù pridelÌ k alokovanej
            if (previous->size < size + sizeof(HEADER) + sizeof(HEADERA)) {
                new_nodeA->size = previous->size;
                previous->size = 0;
                memset(curr_memory + sizeof(HEADER) + sizeof(HEADERA), -1, new_nodeA->size);
                return (curr_memory + sizeof(HEADER) + sizeof(HEADERA));
            }
            //tu sa d· pamaù eöte vyuûiù a preto tu vytv·ram Ôalöiu hlaviËku, ktor· bude ukazovaù na novovzniknut˙ voæn˙ Ëasù pamata
            else {
                HEADER* new_nodeF = (HEADER*)(curr_memory + sizeof(HEADER) + sizeof(HEADERA) + size);
                new_nodeF->size = previous->size - size - sizeof(HEADERA);
                new_nodeF->next = previous->next;
                previous->next = new_nodeF;
                memset(curr_memory + sizeof(HEADER) + sizeof(HEADERA), -1, size);
                return (curr_memory + sizeof(HEADER) + sizeof(HEADERA));
            }

        }

        int i = 1;
        //cyklus, kor˝ sl˙ûi na to, aby som naöiel predch·dzaj˙ci blok pam‰ta a mohol ho spojiù s nov˝m 
        while (i != pozicia - 1) {
            previous = previous->next;
            i++;
        }

        //nejako si potrebujem zabezbeËiù predchodcu pointer curr, pretoûe budem curr vymaz·vaù, pretoûe nebude odkazovaù 
        //voæne miesto v pam‰ti, tak t˝m p·dom mi je tento pointer zbytoËn˝ a mÙûem ho pouûiù skÙr na alok·ciu pam‰te

        if (thebest->size < size + sizeof(HEADER) + sizeof(HEADERA)) {
            char* curr_memory = (char*)thebest;
            int number = thebest->size;
            previous->next = thebest->next;
            HEADERA* new_nodeA = (HEADERA*)curr_memory;
            new_nodeA->size = number;
            memset(curr_memory + sizeof(HEADERA), -1, number);
            return curr_memory + sizeof(HEADERA);
        }

        char* curr_memory = (char*)thebest;

        HEADER* new_nodeF = (HEADER*)(curr_memory + size + sizeof(HEADERA));
        new_nodeF->size = thebest->size - sizeof(HEADERA) - size;
        new_nodeF->next = thebest->next;
        new_nodeF->sizeOfMemory = header->sizeOfMemory;
        previous->next = new_nodeF;

        HEADERA* new_nodeA = (HEADERA*)(curr_memory);
        new_nodeA->size = size;

        memset(curr_memory + sizeof(HEADERA), -1, size * sizeof(char));

        char* returnMemory = (char*)new_nodeA;
        return returnMemory + sizeof(HEADERA);
    }
}


int memory_free(void* valid_ptr) {

    if (!memory_check(valid_ptr)) {
        return 1;
    }
    char* curr_memory = (char*)valid_ptr - sizeof(HEADERA);
    HEADERA* helpMemory = (HEADERA*)curr_memory;
    int sizeOfMemory = helpMemory->size;

    //ak sa do funkcie free poöle NULL pointer

    char* header = (char*)pointer;
    HEADER* hlavicka = (HEADER*)pointer;
    //toto je prÌpad, keÔ uvolÚujem tak˙ pamaù, ktor· væavo susedÌ s hlavnou hlaviËkou, ktor· ukazuje na zaËiatok celÈho poæa
    //mÙûu nastaù 3 prÌpady:

    if (curr_memory == (header + sizeof(HEADER))) {

        //toto je prÌpad ak je v pamati alokovana jedna veæk· pamaù, ktor· ide aû po koniec celeho pola
        if ((curr_memory + sizeof(HEADERA) + sizeOfMemory) == (header + hlavicka->sizeOfMemory)) {
            hlavicka->size += sizeOfMemory;
            memset(curr_memory, -2, sizeOfMemory + sizeof(HEADERA));
            return 0;
        }

        //druh˝ prÌpad je, ûe vpravo od nej je pamaù, ktor· je alokovan· => zv˝öim veækosù voænej pamate v hlavnej hlaviËke
        else if (*(curr_memory + sizeOfMemory + 2 * sizeof(HEADERA)) == -1) {
            hlavicka->size += sizeOfMemory;
            memset(curr_memory, -2, sizeOfMemory + sizeof(HEADERA));
            return 0;
        }

        //tretÌ prÌpad je, ûe vpravo od nej sa nach·dza pamaù, ktor· je taktieû voæn· => spojÌm vöetky bloky pamate
        else if (*(curr_memory + sizeOfMemory + sizeof(HEADERA) + sizeof(HEADER)) == -2) {
            HEADER* remove_memory = (HEADER*)(curr_memory + sizeof(HEADERA) + sizeOfMemory);
            hlavicka->size += sizeOfMemory + sizeof(HEADERA) + remove_memory->size;
            hlavicka->next = remove_memory->next;
            memset(curr_memory, -2, sizeof(HEADER) + sizeOfMemory + sizeof(HEADERA));
            return 0;
        }
        else {
            return 1;
        }
    }
    //prÌpad ak pred danou pam‰ùou je taktieû voæn· pam‰ù 
    else if (*(curr_memory - 1) == -2) {
        //prÌpad ak pred danou pamaùou je voæn· pamaù a z·roven za danou pamaùou je hlaviËka, ktor· ukazuje na Ôalöiu voæn˙ pamaù
        //robÌm to preto, aby som vybral tak˝ blok pamate, s ktor˝m spojim danu pamaù, aby v˝sledn· pamaù bola Ëo najvaËöia


        //ak je toto if pravdivÈ znamen· to ûe dan· pamaù, ktoru chcem uvolniù je ohraniËen· dvoma dalsimi volnymi pamatami -> ze spojim tieto 3 bloky pamate
        //do jednej velkej
        if (*(curr_memory + sizeof(HEADERA) + sizeOfMemory + sizeof(HEADER)) == -2 &&
            curr_memory + sizeof(HEADERA) + sizeOfMemory != header + hlavicka->sizeOfMemory) {

            HEADER* next = (HEADER*)(curr_memory + sizeof(HEADERA) + sizeOfMemory);
            HEADER* previous = (HEADER*)pointer;

            while (previous->next != next) {
                previous = previous->next;
            }

            previous->size += next->size + sizeOfMemory + 2 * sizeof(HEADERA);
            previous->next = next->next;

            curr_memory = (char*)previous + sizeof(HEADER);

            memset(curr_memory, -2, previous->size + sizeof(HEADERA));

            return 1;
        }
        //toto je prÌpad, ak je pred pam‰ùou voæn· pamaù a za pamaùou nie -> takûe spojÌm tieto dve voænÈ pamate do jednej v‰Ëöej
        else {
            int index = 1;
            while (*(curr_memory - index) == -2) {
                index++;
            }
            index--;

            //budem hæadaù index tej hlaviËky ktor· je najbliûöia tejto voænwj pamate

            HEADER* new_header = (HEADER*)(curr_memory - sizeof(HEADER) - index);
            new_header->size += sizeOfMemory + sizeof(HEADERA);

            curr_memory = (char*)valid_ptr;
            memset(curr_memory - sizeof(HEADERA), -2, sizeOfMemory + sizeof(HEADERA));

            return 1;
        }
    }
    //prÌpad, ktor˝ hovorÌ to, ûe uvolnujem tak˙ pamat, ktor· je na konci celeho pola a pred sebou m· alokovanu pamat
    else if (curr_memory + sizeof(HEADERA) + helpMemory->size == header + hlavicka->sizeOfMemory) {
        int index = 1;

        //cyklus mi hæad· najbliûiu hlaviËku voænej pamate, tam nie je tak n·jde hlaviËku, ktor· ukazuje na zaËiatok celeho pola
        while (1) {
            if (*(curr_memory - index) != -1) {
                if (*(curr_memory - index - sizeof(HEADERA)) == -1) { //podmienky pomocou ktor˝ch kontrolujem Ëi sa na danej adrese nenachadza alokovana Ëasù
                    if (*(curr_memory - index - 2 * sizeof(HEADERA)) == -1) {
                        index += 2 * sizeof(HEADERA);
                        continue;
                    }
                    index++;
                    break;
                }
                index++;
                break;
            }
            index++;
        }
        //n·jdenie predch·dzaj˙cej hlaviËky, aby som ju mohol spojiù s novou
        HEADER* previous = (HEADER*)(curr_memory - index - sizeof(HEADER));
        int size = helpMemory->size;
        //nov· hlaviËka
        HEADER* new_header = (HEADER*)(curr_memory);
        new_header->size = size;
        new_header->sizeOfMemory = previous->sizeOfMemory;
        new_header->next = previous->next;
        previous->next = new_header;

        memset(curr_memory + sizeof(HEADER), -2, size + sizeof(HEADERA) - sizeof(HEADER));

        return 1;
    }
    //prÌpad ak pred danou pamaùou nie je voæn· pamaù ale alokovan· a za danou pam‰ùou sa nach·dza hlaviËka voænÈho bloku
    //DONE !!!!!!!
    else if (*(curr_memory + sizeof(HEADERA) + sizeOfMemory + sizeof(HEADER)) == -2) {
        HEADER* next = (HEADER*)(curr_memory + sizeof(HEADERA) + sizeOfMemory);
        HEADER* new_header = (HEADER*)(curr_memory);
        HEADER* previous = (HEADER*)pointer;
        while (previous->next != next) {
            previous = previous->next;
        }

        new_header->sizeOfMemory = previous->sizeOfMemory;
        new_header->size = sizeOfMemory + sizeof(HEADERA) + next->size;
        new_header->next = next->next;

        previous->next = new_header;
        memset(curr_memory + sizeof(HEADER), -2, sizeof(HEADER) + sizeof(HEADERA));

        return 1;
    }
    //prÌpad keÔ pred pamatou je alokovan· aj za pamaùou je alokoivana pamaù
    //OKOMENTOVAT DONE!!!
    else {
        int index = 1;

        //cyklus mi hæad· najbliûiu hlaviËku voænej pamate, tam nie je tak n·jde hlaviËku, ktor· ukazuje na zaËiatok celeho pola
        while (1) {
            if (*(curr_memory - index) != -1) {
                if (*(curr_memory - index - sizeof(HEADERA)) == -1) {
                    if (*(curr_memory - index - 2 * sizeof(HEADERA)) == -1) {
                        index += 2 * sizeof(HEADERA);
                        continue;
                    }
                    index++;
                    break;
                }
                index++;
                break;
            }
            index++;
        }

        //n·jdenie predch·dzaj˙cej hlaviËky, aby som ju mohol spojiù s novou
        HEADER* previous = (HEADER*)(curr_memory - index - sizeof(HEADER));
        int size = helpMemory->size;
        //nov· hlaviËka
        HEADER* new_header = (HEADER*)(curr_memory);
        new_header->size = size;
        new_header->sizeOfMemory = previous->sizeOfMemory;
        new_header->next = previous->next;
        previous->next = new_header;

        memset(curr_memory + sizeof(HEADER), -2, size + sizeof(HEADERA) - sizeof(HEADER));

        return 1;
    }


    return 0;
}

//funkcia, ktora sluûi na spoËÌtanie alokovanej Ëasti pam‰te
void memory_count(void* valid_ptr, int size, int sizeOfAlloc) {
    char* start = (char*)valid_ptr + sizeof(HEADER);
    HEADERA* sizeOfAllocated = (HEADERA*)start;
    int count = sizeof(HEADER);
    int countOfHeaders = 0;
    int curr_memory = sizeof(HEADER);
    int temp;
    printf("\tAlokacia velkosti %dB pri velkosti pamate %dB.\n\n", sizeOfAlloc, size);
    //cyklus bude prebiahaù dovtedy, k˝m sa neprejde celÈ pole
    while (count != size) {
        //cyklus moûe zastaù ak sa na danej adrese nenach·dza -1, Ëo znamen·, ûe sa tam nach·dza bude voæna pamaù alebo nejak· hlaviËka voæneho bloku
        if (*((char*)sizeOfAllocated + sizeof(HEADERA)) != -1 || *((char*)sizeOfAllocated + sizeof(HEADERA) + 1) != -1 && *((char*)sizeOfAllocated + sizeof(HEADERA) + 2) != -1) {
            break;
        }
        count += sizeOfAllocated->size + sizeof(HEADERA);
        temp = sizeOfAllocated->size;
        countOfHeaders++;
        start = (char*)(sizeOfAllocated);
        sizeOfAllocated = (HEADERA*)(start + temp + sizeof(HEADERA));
    }

    count = count - (countOfHeaders * sizeof(HEADERA)) - sizeof(HEADER);
    double percent = (100 * count) / size;
    printf("\tZ celkoveho bloku pamate velkosti %dB je alokovanych %dB, co je %.2f %% z celkovej velkosti.\n\n\n", size, count, percent);

}

//zhodn· funkcia ako memory_count1, len je to vytvorene pre testy, kde sa hodnoty ud·vaj˙
void memory_count2(void* valid_ptr, int size, int from, int to) {
    char* start = (char*)valid_ptr + sizeof(HEADER);
    HEADERA* sizeOfAllocated = (HEADERA*)start;
    int count = sizeof(HEADER);
    int countOfHeaders = 0;
    int curr_memory = sizeof(HEADER);
    int temp;
    printf("\tAlokacia velkosti od %dB do %dB pri velkosti pamate %dB.\n\n", from, to, size);
    while (count != size) {
        if (*((char*)sizeOfAllocated + sizeof(HEADERA)) != -1 || *((char*)sizeOfAllocated + sizeof(HEADERA) + 1) != -1 && *((char*)sizeOfAllocated + sizeof(HEADERA) + 2) != -1) {
            break;
        }
        count += sizeOfAllocated->size + sizeof(HEADERA);
        temp = sizeOfAllocated->size;
        countOfHeaders++;
        start = (char*)(sizeOfAllocated);
        sizeOfAllocated = (HEADERA*)(start + temp + sizeof(HEADERA));
    }

    count = count - (countOfHeaders * sizeof(HEADERA)) - sizeof(HEADER);
    double percent = (100 * count) / size;
    printf("\tZ celkoveho bloku pamate velkosti %dB je alokovanych %dB, co je %.2f %% z celkovej velkosti.\n\n\n", size, count, percent);
}

//testovaË pre test 1
//odsk˙öam tu vöetky funkcie: memory_alloc, memory_free, memory_check aj memory_init
void test1(int size, void* arrayOfPointers[], int sizeOfAlloc) {
    int index = 0;
    memory_init(pointer, size);
    //iterujem aû dovtedy, k˝m mi funkcia malloc nevr·ti NULL Ëo znamen·, ûe uû tam nie je miesto na alok·ciu danej veökosti pam‰te
    while (1) {
        arrayOfPointers[index] = memory_alloc(sizeOfAlloc);
        if (arrayOfPointers[index] == NULL) {
            break;
        }
        index++;
    }
    //n·sledne sa zr·ta % alokovanej pam‰te
    memory_count(pointer, size, sizeOfAlloc);
    //uvoænia sa jednotlive bloky pam‰te
    for (int i = 0; i < index; i++) {
        memory_free(arrayOfPointers[i]);
    }

}
//testovaË na testy 2,3,4
//podobn· funkcia ako na test 1, len s t˝m rozdielom, ûe sa vo funkciÌ generuj˙ n·hodne veækosti pam‰te, ktorÈ budem alokovaù
void test234(int size, void* arrayOfPointers[], int from, int to) {
    HEADER* header;
    HEADERA* headera;
    char* curr;
    int index = 0;
    int random;
    int arr[10000];
    srand(time(0));
    random = (rand() % (to - from + 1)) + from;
    arr[0] = random;
    memory_init(pointer, size);
    //generovanie n·hodn˝ch veækostÌ pam‰te m·m vyrieöenÈ tak, ûe
    while (1) {
        arrayOfPointers[index] = memory_alloc(random);
        if (arrayOfPointers[index] == NULL) {
            break;
        }
        curr = (char*)arrayOfPointers[index] - sizeof(HEADERA);
        headera = (HEADERA*)curr;
        curr = (char*)curr + headera->size + sizeof(HEADERA);
        header = (HEADER*)curr;
        if (header->size > to) {
            random = (rand() % (to - from + 1)) + from;
        }
        else if (header->size == from) {
            random = from;
        }
        else {
            random = (rand() % (header->size - from + 1)) + from;
        }
        index++;
        arr[index] = random;
    }
    memory_count2(pointer, size, from, to);
    for (int i = 0; i < index; i++) {
        memory_free(arrayOfPointers[i]);
    }
    printf("\n");
}


int main() {
    char pole[N] = { 0 };
    pointer = pole;
    int flag = 1;
    int cisloTestu;
    void* arrayOfPointers[60000] = { 0 };
    int index = 0;
    int size = 50;
    int random;
    int random2;

    printf("Testovacie scenare:\n");
    printf("Test 1: Alokacia jednej nahodnej hodnoty od 8-24 byte do inicializovanej pamate velkosti do 50/100/200 byte do zaplnenia pamate.\n");
    printf("Test 2: Alokacia nahodneho poctu byte (8 - 24) do inicializovanej pamate velkosti do 50/100/200 byte do zaplnenia pamate.\n");
    printf("Test 3: Alokacia nahodneho poctu byte (500 - 5 000) byte do inicializovanej pamate velkosti do 10 000 byte do zaplnenia pamate.\n");
    printf("Test 4: Alokacia nahodneho poctu byte (8 - 50 000) byte do inicializovanej pamate velkosti do 65 000 byte do zaplnenia pamate.\n");
    printf("Pre ukoncenie stlacte 0.\n");
    while (flag) {
        printf("Pre spustenie daneho testu stlacte prislusne cislo.\n");
        scanf("%d", &cisloTestu);
        switch (cisloTestu) {
        case 1:
            size = 50;
            srand(time(0));
            random2 = (rand() % (24 - 8 + 1)) + 8;
            for (int j = 0; j < 3; j++) {
                test1(size, arrayOfPointers, random2);
                size += size;
            }
            break;
        case 2:
            size = 50;
            for (int j = 0; j < 3; j++) {
                test234(size, arrayOfPointers, 8, 24);
                size += size;
            }
            break;
        case 3:
            srand(time(0));
            random = (rand() % (10000 - 5000 + 1)) + 5000;
            test234(random, arrayOfPointers, 500, 5000);
            break;
        case 4:
            srand(time(0));
            random = (rand() % (100000 - 50000 + 1)) + 50000;
            test234(random, arrayOfPointers, 8, 50000);
            break;
        case 0:
            flag = 0;
            break;
        default:
            printf("Nespravne cislo testu.\n");
            break;
        }
    }
    return 0;

}
